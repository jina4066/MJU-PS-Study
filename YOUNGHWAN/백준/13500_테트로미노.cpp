#include <bits/stdc++.h>
using namespace std;
int N, M;
const int p[19][3][2] = {
    // 좌우반전과 회전만 고려하여 Shape 만듦. 평행이동은 신경 안쓴다.
    // (y, x)
    // 일자 테트로미노 가능한 shape(2개)
    {{0, 1}, {0, 2}, {0, 3}},
    {{1, 0}, {2, 0}, {3, 0}},
    // 정사각형 테트로미노(1개)
    {{1, 0}, {0, 1}, {1, 1}},
    // L자 테트로미노(8개)
    {{0, 1}, {-1, 1}, {-2, 1}},
    {{-1, 0}, {-2, 0}, {0, 1}},
    {{-1, 0}, {0, 1}, {0, 2}},
    {{0, 1}, {0, 2}, {1, 2}},
    {{-1, 0}, {-2, 0}, {-2, 1}},
    {{-1, 0}, {-2, 0}, {-2, -1}},
    {{0, 1}, {0, 2}, {-1, 2}},
    {{1, 0}, {0, 1}, {0, 2}},
    // T자 테트리미노(4개)
    {{0, -1}, {0, 1}, {-1, 0}},
    {{1, 0}, {-1, 0}, {0, 1}},
    {{0, -1}, {0, 1}, {1, 0}},
    {{-1, 0}, {1, 0}, {0, -1}},
    // Z자 테트리미노(4개)
    {{-1, 0}, {-1, 1}, {-2, 1}},
    {{1, 0}, {1, 1}, {2, 1}},
    {{0, 1}, {1, 1}, {1, 2}},
    {{0, 1}, {-1, 1}, {-1, 2}},
};
int main()
{
    cin.tie(0);
    cin >> N >> M;
    int arr[N][M];
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < M; j++)
        {
            cin >> arr[i][j];
        }
    }
    int max = 0;
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < M; j++)
        {
            for (int t = 0; t < 19; t++)
            {
                if (
                    i + p[t][0][0] < 0 ||
                    i + p[t][1][0] < 0 ||
                    i + p[t][2][0] < 0 ||
                    i + p[t][0][0] >= N ||
                    i + p[t][1][0] >= N ||
                    i + p[t][2][0] >= N)
                {
                    continue;
                }
                if (
                    j + p[t][0][1] < 0 || j + p[t][0][1] >= M ||
                    j + p[t][1][1] < 0 || j + p[t][1][1] >= M ||
                    j + p[t][2][1] < 0 || j + p[t][2][1] >= M)
                {
                    continue;
                }
                int sum = arr[i][j] + arr[i + p[t][0][0]][j + p[t][0][1]] + arr[i + p[t][1][0]][j + p[t][1][1]] + arr[i + p[t][2][0]][j + p[t][2][1]];
                if (max < sum)
                {
                    max = sum;
                }
            }
        }
    }
    cout << max;
}
// 알고리즘 : 입력 개수가 최대 500, 작은 편이라 완전탐색을 사용했다.
// 문제 풀이 방법 : 가능한 모든 테트로미노를 좌표 배열 형태로 나타내고 하나씩 반복문을 통해 조건에 맞는지 판단하는 문제.
// 가능한 테트로미노가 총 19개인데, 좌우반전과 회전만 생각해야됨 -> 평행이동까지 생각해서 생각보다 많은 테트로미노가 생성되었고,
// 오래걸림의 원인이 되었다. 이런 정보는 블로그를 통해 알았음.
// cf ) https://prefer2.tistory.com/entry/%EB%B0%B1%EC%A4%80-14500%EB%B2%88-%ED%85%8C%ED%8A%B8%EB%A1%9C%EB%AF%B8%EB%85%B8-c